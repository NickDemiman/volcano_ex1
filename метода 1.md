# Создание окна
## Подготовка 
Для подготовки работы с Vulkan лучше настроить свой компьютер по следующим рекомендациям [main Vulkano documentation](https://github.com/vulkano-rs/vulkano). 

Сначала необходимо создать файл
`Cargo.toml`. В нем перечисляются все зависимости необходимые для сборки.
```toml 
[package] 
name = "example_project" 
version = "0.0.1" 
authors = ["yourname"] 
edition = "2018" 
[dependencies] 
vulkano = "0.24.0" 
winit = "0.24.0" 
vulkano-win = "0.24.0" 
vulkano-shaders = "0.24.0" 
``` 
Let's go over the dependencies one by one. ```toml vulkano = "0.24.0" ``` Эта библиотека ("crate" в языке Rust) является обёрткой Vulkan API и мы будем её использовать активно для отрисовки всего в нашем окне.  Мы можем использовать вызовы  Vulkan API напрямую (через библиотеку ash) но это сильно усложнить код и количество строк.   ```toml winit = "0.24.0" ``` Эта библиотека необходима для создания окна, т.к. Vulkan не умеет этого. Казалось бы, API для 3д графики а работать с окнами не умеет?   Дело в том, что Vulkan API ответственнен за работу железа ( графической карты или встроенной графической карты цпу). А для создания окна необходимо общение с операционной системой. Отсутствие кода создания окон делает программный интерфейс Vulkan независимым от операционной системы.  А нам необходимо использовать вторую библиотеку для создания окна.  ```toml vulkano-win = "0.24.0" ``` Эта библиотека,  как можно понять из названия, позволяет "подружить" vulkano и winit. Она позволяет узнавать размеры окна, состояние и другие параметры.  

```toml vulkano-shaders = "0.24.0" ``` Эта библиотека нужна для работы с шейдерами в Vulkano.  Шейдер - это маленькая программа, которая работает на устройстве (гпу или встроенная графика) и позволяет обрабатывать данные,  отправленные на отрисовку и создавать графический вывод. Шейдеры пишутся на си подобном  языке GLSL  и затем компилируются в SPIR-V формат. Чтобы не компилировать самостоятельно, эта библиотека аозволяет использовать макрос внутри кода для компиляции шейдеров в правильный формат. 

## Инициализация
Vulkan по сравнению с другими API  требует большое количество строк для инициализации. При его первом изучении может заболеть голова т.к. использует много терминов специфичных для vulkan. Чтобы его понять я бы посоветовал сначала принять на веру что происходит и в дальнейшем работе возвращаться по необходимости. Именно необходимость потребует подправить инициализации и вы увидите как же она влияет на отрисовку. А я попробую объяснить каждую строчку чтобы понять что же здесь происходит.  

#### Imports 
Сначала мы с вами создали `Cargo.toml` файл. Далее создадим `main.rs` файл и в начале файла добавим зависимости. Все перечисленные структуры и трейты будут использоваться в нашем методе`main`. ```rust 
use vulkano::command_buffer::{AutoCommandBufferBuilder, DynamicState, SubpassContents}; 
use vulkano::device::{Device, DeviceExtensions}; 
use vulkano::framebuffer::{Framebuffer, FramebufferAbstract, RenderPassAbstract}; 
use vulkano::image::SwapchainImage; 
use vulkano::instance::{Instance, PhysicalDevice}; 
use vulkano::pipeline::viewport::Viewport; 
use vulkano::swapchain::{AcquireError, PresentMode, SurfaceTransform, Swapchain, SwapchainCreationError}; 
use vulkano::swapchain; 
use vulkano::sync::{GpuFuture, FlushError}; 
use vulkano::sync; 
use vulkano_win::VkSurfaceBuild; 
use winit::window::{WindowBuilder, Window}; 
use winit::event_loop::{EventLoop, ControlFlow}; 
use winit::event::{Event, WindowEvent}; 
use std::sync::Arc; ``` 

#### Instance 

Сперва необходимо создать объект  `Instance`. Это "корневой" объект который нужен для создания остальных структур.  При его созданиинеобходимоуказать какие расширения понадобятся в дальнейшем нашему приложению. Vulkan позволяет использовать графическую карту не только для отрисовки поэтому это выделили в отдельное расширение. Для создания окна требуются некоторые  поэтому используем "статический" метод `vulkano_win::required_extensions()` для их перечисления.
```rust 
let instance = { let extensions = vulkano_win::required_extensions(); Instance::new(None, &extensions, None).unwrap() }; 
``` 

#### Physical Device
После создания инстанса нам необходимо указать какое **физическое устройство** будет использоваться для вычислений. На компьютере может быть несколько устройств который можно использовать для вычислений и в некоторых ситуациях (например в последнем уроке нам потребуется cuda устройство) необходимо указать специфичное устройство. Нам необходимо проверить что выбранное устройство поддерживает расширение для отрисовки графики
```rust 
let physical = PhysicalDevice::enumerate(&instance).next().unwrap(); 
``` 
#### UI 

Теперь нам нужно создать окно для отображения  UI. Строчки ниже позволяют создать окно и **event loop** для обработки событий. 
```rust 
let event_loop = EventLoop::new(); 
let surface = WindowBuilder::new().build_vk_surface(&event_loop, instance.clone()).unwrap(); 
``` 
`event_loop` - это структура,  котор мы будемиспользоватьдля обработки "window events", например нажатия кнопки, передвижения курсора мыши, изменения размера экрана и так далее. Создание `event_loop` не запускает его, это мы сделаем ближе к концу инициализации Vulkan.  `surface` - это то что необходимо самому vulkano. Эта объект описывает внутренее пространство окна на котором будет выполняться отрисовка. 


#### Queue Families 

Далее нам нужно  создать объекты которые специфичны для Vulkan и не встречаются в других API. Предшественник - 
  OpenGL  является *синхронным* API. Это значит что перед тем как отправить данные на устройство, OpenGL ждет пока не получит ответ обратно перед запуском новой программы. Эта концепция проста в понимании но показывает отличие от современного подхода. Современные компьютеры все больше полагаются на *асинхронные* операции. Это позволяет выполнять несколько инструкций одновременно на нескольких устройствах не блокируя главный поток. Для создания асинхронности необходимо указать очередь (*queues*) в Vulkan. Вместо того чтобы отправлять команды по одной, мы будем отправлять их по несколько за один раз. Графическая карта начнёт их выполнять не блокируя программу на  цпу. 
Разница между `Queue` и `QueueFamily` можно рассматривать таким образом:  `QueueFamily` - это **описание** очереди операций на гпу (можно рассматривать как Factory класс для создания `Queue`) , а  `Queue` - это очередь выбранного типа операций. Очередей может быть создано несколько в одном приложении для ускорения но в этом уроке оставим  только одну для простоты. 
```rust 
let queue_family = physical.queue_families().find(|&q| { q.supports_graphics() && surface.is_supported(q).unwrap_or(false) }).unwrap(); 
``` 
Здесь мы запрашиваем 
`QueueFamily` который поддерживает операции отрисовки. Позже мы запросим ещё один для переноса данных на устройство, но пока оставим одно для простоты. Мы проверяем каждый доступный  `QueueFamily` и выбираем который поддерживает отрисовку *и* поддерживается нашим `surface`.  

#### Device
После создания очереди необходимо создать объект 
  `Device` объект.  Он является  *программным* представлением физического устройства (гпу). Для его создания необходимо перечислить некоторые конфигурационные параметры при его создании. В результате мы создадим сам объект `Device` и массив `Queue` в которые мы сможем публиковать команды для выполнения на гпу. 
```rust 
let device_ext = DeviceExtensions { khr_swapchain: true, .. DeviceExtensions::none() }; 
let (device, mut queues) = Device::new(physical, physical.supported_features(), &device_ext, [(queue_family, 0.5)].iter().cloned()).unwrap();
```
Также как и при создании `Instance` нам необходимо указать какие расширения необходимы для работы программы. 
В переменной `device_ext` мы указываем что нам нужен расширение swapchain (о свапчейне будет рассказано далее) и остальные расширения по умолчанию. Для создания `Device` необходимо передать в качестве аргументов исполняемый `PhysicalDevice`, список расширений и массив кортежей, которые имеют формат `(QueueFamily, f32)` где цифра означает приоритет в интервале от `0.0` до `1.0`. 

#### Queues 

После создания обьекта`Device` нам доступен итерации обьектов `Queue`. Так как в нашем примере пока только одна очередь, то возьмем первым объект в итераторе. 

```rust 
let queue = queues.next().unwrap(); 
``` 

#### Swapchains и Images 

Обьект `Image` в Vulkan является буфером в котором Vulkan может хранить или извлекать данные. Обычно в нем хранится  2D отрендеренное изображение после рендер пайплайна. Однако, Vulkan `Image` может хранить и другие форматы данных. `Swapchain` - это объект который хранит массив с двумя или более объектами `Image` для отображения изображения на экране. Он работает следующим образом: пока одно изображение отображения на экране пользователя, в буффер других изображений рендерится следующий кадр. Когда кадр готов, они меняются местами (происходит swap изображений) и процесс повторяется. 
```rust 
let (mut swapchain, images) = { 
let caps = surface.capabilities(physical).unwrap(); 
let usage = caps.supported_usage_flags; 
let alpha = caps.supported_composite_alpha.iter().next().unwrap(); 
let format = caps.supported_formats[0].0; 
let dimensions: [u32; 2] = surface.window().inner_size().into(); 
Swapchain::new(device.clone(), surface.clone(), caps.min_image_count, format, dimensions, 1, usage, &queue, SurfaceTransform::Identity, alpha, PresentMode::Fifo, FullscreenExclusive::Default, true, ColorSpace::SrgbNonLinear).unwrap() }; 
``` 
`caps` и `usage` параметры которые указывают какие требования следует использовать при создании swapchain. Здесь мы указываем что мы будем использовать альфа канал в цвете для совмещения нескольких обьектов. Это нам потребуется при отрисовке интерфейса.
`format` - это порядок битов в буфере `Image` для описания цвета. По умолчанию создаётся rgba формат, где каждый цвет описывается 32 битами. 
`dimensions` - это размер нашего окна. 

#### массив вершин (Vertex) 

Самым главным типом в компьютерной графике является вершина (`Vertex`). Минимальное описание вершины является массив от двух идо четырёх координат для описания точки в пространстве.  3 точки вместе описывают треугольник,  базовый элемент для описания объектов. Всё остальные 3д объекты (сфера, цилиндр, дом итд) являются комбинацией треугольников. Обычно эту комбинацию называют "mesh" в 3д моделировании. В Vulkan `Vertex` эта та информация, которую мы отправляем на рендеринг в пайплайн. Они являютсяэлементами над которыми работают шейдеры. В Vulkano есть вспомогательный макрос для импортирования `Vertex`. С помощью него мы можем создать свою структуру с описанием вершины и его полей и импортировать для отрисовки.  
```rust 
#[derive(Default, Debug, Clone)] struct Vertex {
position: [f32; 3],
col:[f32; 4]
 } 
vulkano::impl_vertex!(Vertex, position, col); 
``` 
Макрос берет имя структуры и его полей в качестве аргументов. 
#### Шейдеры 
Теперь нам необходимо создать шейдер, программу которая будет обрабатывать наши вершины и отрисовывать их. В Vulkan шейдеры пишутся на языке  *GLSL* и затем компилируются в SPIR-V формат. И скомпилированная программа загружается на гпу. После отправки новой порции данных, гпу будет вызывать наши шейдеры для создания изображения. Шейдеры могут вызваться на разных этапах рендеринга. На картинке в синих прямоугольниках изображены этапы, где мы можем добавить собственные шейдеры для управления рендерингом. 

На данном этапе мы хотим создать простой шейдер для отрисовки треугольника. Для этого нам понадобятся два шейдера: vertex shader и fragment shader. Первый отвечает за обработку вершин и их положение в 3д, а второй – за раскраску обьектов.
```rust
 mod vs {
 vulkano_shaders::shader!{
 ty: "vertex", 
src: " #version 450
 layout(location = 0) in vec3 position; 
void main() { gl_Position = vec4(position, 1.0);
 }" 
}
 } 
mod fs { vulkano_shaders::shader!{
 ty: "fragment", 
src: " #version 450
 layout(location = 0) out vec4 f_color;
 void main() {
 f_color = vec4(1.0, 0.0, 0.0, 1.0); } " 
} 
} 
let vs = vs::Shader::load(device.clone()).unwrap();
 let fs = fs::Shader::load(device.clone()).unwrap();
 ```

Это сильно похоже на костыль, но таким образом разработчики Vulkano добавили возможность импортировать шейдер напрямую не отвлекаясь на компиляцию GLSL. Это выполнено в виде макрос, который использует внешнюю утилиту для сборки за разработчика автоматически, чтобы он не отвлекайся от написания кода.  Первый шейдер "vertex shader», который выполняется на каждой вершине которая есть на входе. Например у треугольника три вершины и этот шейдер будет выполнен трижды, но каждый со своими вершинами. Если нам потребуется двигать объекты мышкой, то этот шейдер сможет справиться с этим не изменяя наши данные. Второй шейдер называется "fragment shader" и работает на каждом «треугольнике» и раскручивать их.   Теперь давайте рассмотрим уод шейдеров. 
`layout(location = 0) in vec3 position;` 
Говорит, что мы ожидаем на входе значение с тремя координатами (vec3). Модификатор `layout` сообщает, что первыми в массиве данных будут наши координаты вершин. Также как и в C или Rust, мы имеем функцию  `main`. На самом деле мы могли бы ей дать любое имя  и при добавлении шейдера в пайплайн явно указать название функции для выполнения. Но пока будем следовать стандартам.RuВ шейдере мы выставляем позицию вершины  `gl_Position = vec4(position, 1.0);`. `gl_position` vec4 но мы имеем только vec3. Язык умеет преобразовывать vec3 в vec4 если ему дать в конструктор недостающие значения. Четвёртый элемент обычно принимает два значения: ноль или единица. Грубо говоря,  при выставлении значения в единицу следует понимать эту точку как вершину в пространстве. Если ноль, то стоит относиться как к вектора направления.  Они нам потребуются для перемещения и поворота объектов на сцене. В fragment shader стоит обратить внимание на строку  `layout(location = 0) out vec4 f_color;`. Она очень похожа по смыслу на строку в vertex shader но имеет модификатор `out`. Он говорит что на *выходе* шейдера будет массив из четырёх переменных.  Также стоит сказать что в отличие от vertex shader этот параметр не встроенный иего необходимо явно объявить. 

#### Graphics Pipeline 

#### Renderpass 

Теперь мы подходим все ближе к рендерингу изображений.   `Renderpass` - структура, которая описывает процесс и этапы рендеринга (превращения данных в 2д изображения). Для упрощения создания в vulkano существует макрос для создания этой структуры ( на этапе компиляции вместо макрос будет подставлен rust код, т.е. мы можем написать его и сами, но таким образом нам требуется значительно меньше строчек кода). В этом макрос необходимо указать `ImageAttachment` ы которые будут рендериться и `Subpass`ы которые будут выполняться.  Один Subpass - это один вызов шейдер пайплайна. В следующих уроках нам потребуется несколько сабпассов для рендеринга. `ImageAttachment`  лучше представлять как описание требований нашего будущего изображения. 
```rust 
let render_pass = Arc::new(vulkano::single_pass_renderpass!( device.clone(), 
attachments: { 
color: { 
load: Clear, 
store: Store, 
format: swapchain.format(), 
samples: 1, } 
}, 
pass: { 
color: [color], 
depth_stencil: {} 
} ).unwrap()); 
``` 
Здесь вы можете увидеть, что мы создали один аттачмент под названием `color` ( Имя можно поменять на любое удобное для вас). Мы указали,  `format: swapchain.format()` , что буфер будущего изображения будет иметь такой же формат как буфер в swapxhain (rgba32 если что).  Далее мы указали`load: Clear` который говорит что при каждом новом рендеринге необходимо очистить буфер (чтобы не было повторов изображения при перемещении объекта, например)  `store: Store` говорит Vulkan'у что необходимо сохранять буфер, и `samples: 1` говорит что не будем использоватьмультисемплирование. В поле `pass:` указывается что будет только один Subpass, и на выходе в color attachment будет наш `ImageAttachment` под названием `color`. 

#### GraphicsPipeline 

Обьект  `GraphicsPipeline` является следующим необходимым компонентом для использования `RenderPass`.  `RenderPass` сообщает Vulkan какие объекты будут доступны и в каком порядке следует обращаться.  `GraphicsPipeline` сообщает Vulkan *какие* шейдеры следует использовать и в каком виде будут данные массива.  Также нам потребуется создать структуру `DynamicState`.  Она используется для динамического присваивания размера параметров scissors и viewports без необходимости пересоздания`GraphicsPipeline` при изменении размера окна. 
```rust 
let mut dynamic_state = DynamicState { line_width: None, viewports: None, scissors: None, compare_mask: None, write_mask: None, reference: None }; 
 let pipeline = Arc::new(GraphicsPipeline::start() .vertex_input_single_buffer() .vertex_shader(vs.main_entry_point(), ()) .triangle_list() .viewports_dynamic_scissors_irrelevant(1) .fragment_shader(fs.main_entry_point(), ()) .render_pass(Subpass::from(render_pass.clone(), 0).unwrap()) .build(device.clone()) .unwrap());
  ``` 
 Рассмотрим что здесь происходит.  `.vertex_input_single_buffer()` говорит что на входе рендеринга будет один буфер.  `.vertex_shader(vs.main_entry_point(), ())` говорит Vulkan'у, какую функцию следует вызвать внутри шейдера. `.triangle_list()` говорит Vulkan'у, что следует рассматривать буфер как набор вершин треугольников (Есть и другие форматы). `.viewports_dynamic_scissors_irrelevant(1)` сообщает что   viewports и scissors будут задаваться динамически. `.fragment_shader(fs.main_entry_point(), ())` сообщает что использовать за функцию для входа в fragment shader.  `.render_pass(Subpass::from(render_pass.clone(), 0).unwrap())` говорит какой subpass следует использовать в нашем `RenderPass`. В следующих уроках нам потребуется создавать несколько, это важный параметр для управления процессом рендеринга.  Но сейчас нам достаточно иметь и один subpass. `.build(device.clone())` создаёт структуру `GraphicsPipeline` с заданным свойствами. 
#### Буферы
Чтобы что-то нарисовать, нам необходимо создать буферы данных. Мы можем использовать `CpuAccessibleBuffer` из библиотеки Vulkano. Он прост в создании и управлении, но в следующих уроках нам понадобится использовать другую схему создания.
```rust 
let vertex_buffer = CpuAccessibleBuffer::from_iter(device.clone(), BufferUsage::all(), false, [ 
Vertex 
{ position: [-0.5, 0.5, 0.0] },
 Vertex
 { position: [0.5, 0.5, 0.0] }, 
Vertex 
{ position: [0.0, -0.5, 0.0] } ].iter().cloned()).unwrap(); 
```
 Так мы создали `CpuAccessibleBuffer` и заполнили вершинами. При их изменении наш треугольник будет менять свое положение на экране.

#### Call our render code 




#### Framebuffers 

При создании объекта `Renderpass` мы также описали один  "image attachment". Однако  Vulkan'у известно только как изображение *будет* выглядеть. Перед тем как отрисовывать что-либо нам необходимо создать сам  `Framebuffer`. 
```rust 
let mut framebuffers = window_size_dependent_setup(&images, render_pass.clone(), &mut dynamic_state); 
``` 
функция `window_size_dependent_setup` пока описана в форме вызова для краткости. Первым аргументом передается borrow обьектов `Image`. Вторым аргументом является Arc ссылка на рендер пасс к которому будут привязаны  `Framebuffer`ы 
, и последним аргументом является `DynamicState` структура
```rust 
fn window_size_dependent_setup( images: &[Arc<SwapchainImage<Window>>], render_pass: Arc<dyn RenderPassAbstract + Send + Sync>, dynamic_state: &mut DynamicState ) -> Vec<Arc<dyn FramebufferAbstract + Send + Sync>> { 
let dimensions = images[0].dimensions(); 
let viewport = Viewport { origin: [0.0, 0.0], dimensions: [dimensions[0] as f32, dimensions[1] as f32], depth_range: 0.0 .. 1.0, }; 
dynamic_state.viewports = Some(vec!(viewport)); 
images.iter().map(|image| { 
Arc::new( Framebuffer::start(render_pass.clone()) .add(image.clone()).unwrap() .build().unwrap() ) as Arc<dyn FramebufferAbstract + Send + Sync> 
}).collect::<Vec<_>>() 
} 
``` 


--- 

Поздравляю,  мы проинициализировали 
Vulkan! И теперь мы можем  заняться самим рендерингом в нашем окне. С появлением новых требований к нашей программе потребуется вносить изменения в эти объекты но общий вид инициализации будет неизменным. 

## Рендеринг 

Теперь мы готовы заняться рендерингом. И в этом уроке отрисуем базовый треугольник. 

#### Пара переменных 

Перед запуском цикла событий приложения (event_loop) нам потребуется создать две изменяемые переменные.  
```rust 
let mut recreate_swapchain = false; 
```
Наш   swapchain в процессе работы может принять невалидное состояние по множеству причин, некоторыми из них мы не можем повлиять. Наиболее часто встречается, к примеру,  это изменение размера окна. Это приводит к несоответствию размеров  `Image` в swapchain и текущим состоянием размера окна. При попытке рендеринга Vulkan выдаст ошибку и чтобы наше приложение не падало, нам потребуется пересоздавать swapchain.
```rust l
et mut previous_frame_end = Some(Box::new(sync::now(device.clone())) as Box<dyn GpuFuture>);
``` 

Рпнее мы говорили что Vulkan  *асинхроннен*. Для поддержки общения между цпу и гпу в Vulkano  используется подход на основе своего рода промимов (Promises). В Vulkano это реализовано через структуры наследованные от трейта `GpuFuture`. Создание этой структурыне начинает никакой работы на гпу (это следует помнить на следующих уроках).  Работа отправляется на гпу после вызова метода flush(). Команды выполняются асинхронно т.е. они *выполняться* даже после вызова метода и закончить свою работу значительно позже. Если мы удалим структуру,  то главный поток заблокируют я и будет ждать пока не завершится работа на гпу. В идеале нам следует стремиться чтобы наше приложение и гпу работали постоянно без ожиданий. Изменяемая переменная `previous_frame_end` будет использоваться чтобы запоминать последнюю работу отправленую на гпу при обработке события нового кадра. 

#### Цикл событий 

Код обработки цикла событий выглядит как бесконечный цикл, в котором мы будем обрабатывать каждое событие, например событие закрытия окна. Вся логика приложения будет происходить здесь.
```rust 
event_loop.run(move |event, _, control_flow| 
{ // exciting stuff goes here 
}); 
``` 

#### События 

Для обработки событий сначала добавим `match` блок для ветвления кода в зависимости от типа события. Сначал добавим обработку событий при закрытии приложения, события для пересоздания swapchain и события при запросе отображения нового кадра. 
```rust 
event_loop.run(move |event, _, control_flow| { 
match event { 
Event::WindowEvent { 
event: WindowEvent::CloseRequested, .. } => { 
*control_flow = ControlFlow::Exit; 
},
Event::WindowEvent { 
event: WindowEvent::Resized(_), .. } => { 
recreate_swapchain = true; 
}, 
Event::RedrawEventsCleared => { 
// do our render operations here 
}, 
() => {} 
} 
}); 
``` 
Если вы недавно начали изучать Rust то вас может смутить последняя строчка `() => {}`.  `match` блок в Rust должен обрабатывать *всевозможные* случаи. И таким образоммы указываем, что для всех остальных случаев следует ничего не делать. 

#### Очистка 

В начале цикла событий добавлена строчка
```rust previous_frame_end.as_mut().take().unwrap().cleanup_finished(); 
``` 
Она нужна для проверки результата работы на гпу. Мы берём последний `GpuFuture` проверяем что операция завершилась и освободила ресурсы (например буфер с вершинами).  Эта операция асинхронна. 

#### Пересоздание swapchain 

В начале каждого рендеринга кадра нам 5ужно проверять, нужно ли пересоздавать swapchain. 
```rust 
if recreate_swapchain { 
let dimensions: [u32; 2] = surface.window().inner_size().into();
let (new_swapchain, new_images) = match swapchain.recreate_with_dimensions(dimensions) { 
Ok(r) => r, 
Err(SwapchainCreationError::UnsupportedDimensions) => return, 
Err(e) => panic!("Failed to recreate swapchain: {:?}", e) 
}; 
swapchain = new_swapchain; 
framebuffers = window_size_dependent_setup(&new_images, render_pass.clone(), &mut dynamic_state); 
recreate_swapchain = false; 
} 
``` 
Сначала нам нужно получить текущие размеры окна.  Vulkano имеет полезный метод  `recreate_with_dimension`, который создаёт новый swapchain со старыми опциями, но новыми размерами окна. На выходе получаем те же параметры что и при первом создании - `Swapchain` и  `Vec` изображений. Следует заметить что также используется обработка ошибок на этом этапе. При ошибке `SwapchainCreationError::UnsupportedDimensions` мы ничего не делаем, так как она может появиться при изменении размера окна и после того как пользователь отпустит кнопку мыши, мы сможем пересоздать swapchain и продолжить работу.  После успешного пересоздания нам нужно обновить фреймбуферы. Дело в том что они зависят  от `Image` и нам требуется обновить также и их.
Для этого воспользуйся повторно `window_size_dependent_setup`. 

#### Получение изображения 

Перед рендерингом нам нужно получить из swapchain `Image` на котором будет отрисованы наши данные.
```rust 
let (image_num, suboptimal, acquire_future) = match swapchain::acquire_next_image(swapchain.clone(), None) { 
Ok(r) => r, 
Err(AcquireError::OutOfDate) => { 
recreate_swapchain = true; return; 
},
Err(e) => panic!("Failed to acquire next image: {:?}", e) 
}; 
if suboptimal { 
recreate_swapchain = true; 
} 
```
На выходе мы получаем  индекс `Image`  в нашем swapchain для рендеринга, `GpuFuture` для описания состояния нашей рендеринг системы. Он требуется чтобы убедиться в том, что мы получили буфер на который будет выполняться отрисовка. И третий аргумент это переменная , Vulkano returns a `suboptimal` которая говорит о том, что нам потребуется пересоздать swapchain при следующем рендеринге. 

#### фоновый цвет 

Небольшая строка которая задаёт фоновый цвет в rgba32 формате. 

```rust 
let clear_values = vec!([0.0, 0.0, 0.0, 1.0].into());
``` 

#### Command Buffer 

Наконец мы добрались до создания команды отрисовки. Для этого нам нужно создать объект  `CommandBuffer` который будет хранить набор команд для отрисовки.  Для уменьшения количества переданных данных между цпу и гпу (т.к. это дорогая по времени операция) мы будем их отправлять по несколько за один раз. Для этого нам нужно:
1. Создать `AutoCommandBufferBuilder` и добавить команды
2: собрать наш `CommandBuffer` 
```rust 
let mut cmd_buffer_builder = AutoCommandBufferBuilder::primary_one_time_submit(device.clone(), queue.family()).unwrap();
cmd_buffer_builder .begin_render_pass(framebuffers[image_num].clone(), SubpassContents::Inline, clear_values) .unwrap() .end_render_pass() .unwrap();
let command_buffer = cmd_buffer_builder.build().unwrap();
``` 
Vulkano имеет отличный `AutoCommandBufferBuilder` объект для создания списка команд. Первым аргументом является устройство на котором будут выполняться операции. Вторым - семейство очереди (`QueueFamily`) в котором будут выполняться операции. Пока в этом уроке у нас только один `Queue` с одним `QueueFamily`.  Перед началом рендеринга необходимо обозначить билету что мы начинаем RenderPass. Этт делается с помощью функции  `.begin_render_pass`. 

Чтобы отрисовать треугольник необходимо вызвать метод `.draw`

  ```rust 

.draw(pipeline.clone(), &dynamic_state, vertex_buffer.clone(), (), (), vec![]).unwrap()

 ``` .  `draw` берет пайплайн который необходимо выполнить, буферы с данными и начинает отрисовку.  


В конце выполнения `draw` команд необходимо вызвать `.end_render_pass`. Чтобы собрать наш`CommandBuffer` необходимо вызвать метод `.build` 

#### Выполнение на гпу 

После создания команд нам необходимо выполнить их на нашем устройстве. Чтобы этого достичь нужно выстроить цепочку выполнения наших `GpuFuture`. В самом последнем обязательно должен быть метод `flush` т.к. он начинает отправку команд на устройство.  Картинка должна помочь в каком порядке начинают выполняться команды.



```rust 
let future = previous_frame_end.join(acquire_future) 
.then_execute(queue.clone(), command_buffer).unwrap()
.then_swapchain_present(queue.clone(), 
swapchain.clone(), image_num)
.then_signal_fence_and_flush();
``` 
Первой вызывается команда `.join`. Её результатом будет проверка того, что к ее концу выполняться оба `GpuFuture` хранимые в `previous_frame_end` и `acquire_future`. То есть это значит что будет осуществлена проверка, что выполнена вся работа на предыдущем кадре и swapchain нам выдал новый буфер для отрисовки. Только по их *окончанию* будут запущены последующие команды. Далее с помощью метода `then_execute` мы отправляем  `CommandBuffer` в очередь `Queue` на отрисовку. `then_swapchain_present` говорит что нужно освободить текущий `Image` и вывести его на экран. И в конце `then_signal_fence_and_flush`, она сигнализирует `fence` (это объект в Vulkan API , который работает как семафор между цпу и гпу) что работает выполнена и запускает цепочку `GpuFuture`. Если мы не будем вызывать этот метод, то никакие команды не будут отправлены на гпу. 

#### Сохранение последней отправленного операции 

Мы закончили обработку текущего кадра и нам нужно сохранить последнюю отправленную команду в `previous_frame_end`. Код ниже сохраняет если удалось отправить на выполнение всю цепочку, иначе вызывает синхронизацию с устройством   ждет когда закончатся все операции на нем и создаёт пустой `GpuFuture` с текущим состоянием. 

```rust 
match future {
Ok(future) => { previous_frame_end = Some(Box::new(future) as Box<_>); } 
Err(FlushError::OutOfDate) => { 
recreate_swapchain = true; previous_frame_end = Some(Box::new(sync::now(device.clone())) as Box<_>); 
} 
Err(e) => {
println!("Failed to flush future: {:?}", e);
previous_frame_end = Some(Box::new(sync::now(device.clone())) as Box<_>); 
} 
} ``` 

#### Сборка 

Чтобы собрать наш код просто выполните в терминале команду 
`cargo run` и увидите ваше окно с треугольником. Поздравляю! Вы выжили до конца урока и смогли собрать приложение (к тому же, скорее всего  на абсолютноновом для вас языке). 


